<!DOCTYPE html>
<html>
<head>
<title>doc.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="content">Content</h1>
<ul>
<li><a href="#content">Content</a></li>
<li><a href="#block-design-concept-of-the-solution-functionionality-and-the-proposed-mechanism-for-analyzing-protocols-on-different-layers">Block design (concept) of the solution functionionality and the proposed mechanism for analyzing protocols on different layers.</a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#capabilities">Capabilities</a></li>
<li><a href="#architecture">Architecture</a></li>
<li><a href="#output">Output</a></li>
</ul>
</li>
<li><a href="#implementation">Implementation</a>
<ul>
<li><a href="#preprocessing">Preprocessing</a></li>
<li><a href="#core-processes">Core processes</a>
<ul>
<li><a href="#packet-class">Packet class</a></li>
<li><a href="#layers">Layers</a></li>
<li><a href="#statistics">Statistics</a></li>
</ul>
</li>
<li><a href="#filter-communication">Filter communication</a></li>
<li><a href="#output-1">Output</a></li>
</ul>
</li>
<li><a href="#statistics-1">Statistics</a></li>
<li><a href="#example-of-external-file-structure-for-specifying-protocols-to-be-analyzed">Example of external file structure for specifying protocols to be analyzed.</a></li>
<li><a href="#the-choice-of-the-implementation-environment">The choice of the implementation environment</a></li>
<li><a href="#summary">Summary</a>
<ul>
<li><a href="#used-libraries">Used libraries</a></li>
<li><a href="#used-tools">Used tools</a></li>
<li><a href="#used-sources">Used sources</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="block-design-concept-of-the-solution-functionionality-and-the-proposed-mechanism-for-analyzing-protocols-on-different-layers">Block design (concept) of the solution functionionality and the proposed mechanism for analyzing protocols on different layers.</h1>
<h2 id="introduction">Introduction</h2>
<p>The main goal of the project is to create a tool for analyzing network protocols on different layers. The tool is designed like wireshark for school PKS (computer and communicative networks) subject. The tool is written in Python 3.11. How to start program is described in the <a href="../README.md">README.md</a> file.</p>
<h2 id="capabilities">Capabilities</h2>
<p>There are two main capabilities of the tool. The first one is to analyze all pcap file and give ipv4 statistics, the ref: <em>Wireshark -&gt; Statistics -&gt; IPv4 Statistics -&gt; Source and Destination Addresses</em>. Second one is to analyze only one protocol.<br>
All output is in yaml format and saved in <code>analyzer/results</code> directory.</p>
<h2 id="architecture">Architecture</h2>
<p>The tool is divided into three main parts:</p>
<ol>
<li>
<p><strong>Preprocessing</strong> - this part is responsible for validation of input arguments, loading my library, reading pcap file and calling the right analyzer.</p>
</li>
<li>
<p><strong>Core processes</strong> - this part is responsible for creating a list of packets. Each packet is an object of class <code>Packet</code> which contains all information about the packet. Based on the input arguments, the two situations can occur, the first one is to analyze all protocols, the second one is to analyze only one protocol. In the second case, the tool will call one of the analyzers, which will analyze only one protocol.</p>
</li>
<li>
<p><strong>Output</strong> - this part is responsible for creating yaml output and saving it to the file. In the end will be created an instance of module <code>tcp_ip.yaml</code> which will create yaml output. Based on diffuculty of output.</p>
</li>
</ol>
<h2 id="output">Output</h2>
<p>The output is in yaml format and saved in <code>analyzer/results</code> directory. The output name is of <code>(&quot;%Y%m%d-%H%M%S&quot;)</code> format. If protocol filter is used, the output will specify the protocol name.</p>
<h1 id="implementation">Implementation</h1>
<p>Here is a activity diagram of the tool. It shows how the tool works. And now ill describe each part of the tool.</p>
<p><img src="images/Activity_of_NA.svg" alt="Activity diagram"></p>
<h2 id="preprocessing">Preprocessing</h2>
<p>There are only two things to pay attention to here. The first one is to parse protocols file. That file consists of all protocols which can be analyzed. It have hex or decimal number and name of protocol. My library is responsible for parsing this file, with <code>parse_file</code> function. And saving all that information.</p>
<p>And last thing are classes of <strong>communications</strong> module. They are blackbox classes that is responsible for analyzing a specified protocol. They are called from <code>main.py</code> file.</p>
<h2 id="core-processes">Core processes</h2>
<p>Lets break <code>Packet</code> class object. Here is a container diagram with flowchart in it, describing how it works.</p>
<p><img src="images/packet_container.svg" alt="Packet class"></p>
<h3 id="packet-class">Packet class</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> <span class="hljs-title">Packet</span> {
    <span class="hljs-function">Layers <span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_all</span>(<span class="hljs-params"></span>)</span>;
    <span class="hljs-function">dict <span class="hljs-title">get_packet</span>(<span class="hljs-params"></span>)</span>;
}
</div></code></pre>
<p>This class is responsible for creating a packet object. It takes a packet from pcap file and creates a packet object. Each layer has its own abstract class <code>Layer</code>. This class is responsible for creating a layer object. Each layer has its own class. For example, <code>Ethernet</code> class is responsible for creating an object of class <code>Ethernet</code>. This class is also responsible for printing all information about packet and creating a dictionary of packet. This dictionary is used for creating yaml output.</p>
<h3 id="layers">Layers</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Layer</span> {
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_all</span>(<span class="hljs-params"></span>)</span>;
    Union[String,None] resolve_type(hex);
    <span class="hljs-function">dict <span class="hljs-title">get_packet</span>(<span class="hljs-params"></span>)</span>;
}
</div></code></pre>
<p>To create next layer, the previous layer must be created. For example, to create <code>IPv4</code> layer, the <code>Ethernet</code> layer must be created.<br>
So if layer 2 isnt created, the layer 3 cant be created.</p>
<h3 id="statistics">Statistics</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> <span class="hljs-title">Statistics</span> {
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_statistics</span>(<span class="hljs-params"></span>)</span>;
    list[dict[str, str]] get_all_senders();
    list[str] get_max_send_packets_by();
}
</div></code></pre>
<p>Object type <code>Packet</code> needs a <code>Statistics</code> object. This object is responsible for creating statistics of ipv4. It creates a dict of all senders and count of packets.</p>
<h2 id="filter-communication">Filter communication</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> <span class="hljs-title">Com</span> {
    <span class="hljs-function">dict <span class="hljs-title">to_yaml</span>(<span class="hljs-params"></span>)</span>;
}
</div></code></pre>
<p>This is abstract class of all filter communications. In the <code>main.py</code> file is created one of the filter communication class. This class is responsible filtering out packets looking for specified protocol. For example, if the protocol is <code>ARP</code>, the <code>ARPCom</code> class is created. This class is responsible for filtering out packets looking for ARP protocol.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> <span class="hljs-title">ARPCom</span> <span class="hljs-title">extends</span> <span class="hljs-title">Com</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> _parse_packets();
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_result</span>(<span class="hljs-params"></span>)</span>;
    <span class="hljs-function">dict <span class="hljs-title">to_yaml</span>(<span class="hljs-params"></span>)</span>;
}
</div></code></pre>
<p><img src="images/container_na.svg" alt="Filter Container"></p>
<h2 id="output">Output</h2>
<p>I have <code>Basic</code> and <code>Advanced</code> output classes. The second one extends the first one. The first one is responsible for creating basic yaml output. For all protocols. It have main logic.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> <span class="hljs-title">Basic</span> {
    <span class="hljs-function">dict <span class="hljs-title">create_data_to_dump</span>(<span class="hljs-params"></span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create_file</span>(<span class="hljs-params"></span>)</span>;
}
</div></code></pre>
<p><code>Basic</code> class as the next one gets already parsed list of packets. It creates a dictionary and go throw all packets, calles their <code>get_packet</code> function that returns a dictionary of packet. And then it creates a yaml output.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> <span class="hljs-title">Advanced</span> <span class="hljs-title">extends</span> <span class="hljs-title">Basic</span> {
    <span class="hljs-function">dict <span class="hljs-title">create_data_to_dump</span>(<span class="hljs-params"></span>)</span>;
}
</div></code></pre>
<p>The difference between <code>Basic</code> and <code>Advanced</code> class is that the second one gets an instance of Com communication and calls its <code>to_yaml</code> function. This function returns a dictionary. And then it creates a yaml output.</p>
<h1 id="statistics">Statistics</h1>
<p>Its a global class that saves statistics of all packets. All packets saves their information to this class. And then, at the end output class puts this information to the yaml output.</p>
<h1 id="example-of-external-file-structure-for-specifying-protocols-to-be-analyzed">Example of external file structure for specifying protocols to be analyzed.</h1>
<pre class="hljs"><code><div>#ListOfEthernetII
0200 XEROX
0201 PUP
0800 IPv4
...
#ListOfIPv4
01 ICMP
02 IGMP
...
</div></code></pre>
<p>I use that file for parsing protocols. It is in <code>analyzer/protocols/set.txt</code> file. It is parsed by my library.</p>
<h1 id="the-choice-of-the-implementation-environment">The choice of the implementation environment</h1>
<p>I use Python 3.11. I use it because I have experience with it. I use it for school and for my personal projects. I use it for writing scripts and for writing web applications. It also easier to create programs with Py.</p>
<h1 id="summary">Summary</h1>
<p>The idea to create own tool for analyzing network protocols on different layers is very interesting. I have learned a lot of new things. Too bad that only the yaml output that we are forced to do cannot be changed. I would add/change a couple of things there. But I understand that its easier to control and check them for specified schema.</p>
<h2 id="used-libraries">Used libraries</h2>
<ul>
<li><strong>scapy</strong> - for reading pcap file and creating packets</li>
<li><strong>argparse</strong> - for parsing input arguments</li>
<li><strong>ruamel.yaml</strong> - for creating yaml output</li>
</ul>
<h2 id="used-tools">Used tools</h2>
<ul>
<li><strong>vscode</strong> - for writing code</li>
<li><strong>wireshark</strong> - for testing and debugging</li>
<li><strong>git</strong> - for version control</li>
</ul>
<h2 id="used-sources">Used sources</h2>
<ul>
<li><strong>TFTP Guide</strong> - http://www.tcpipguide.com/free/t_TFTPDetailedOperationandMessaging-3.htm</li>
<li><strong>The Task</strong> - https://github.com/fiit-ba/pks-course/tree/main/202324/assignments/1_network_communication_analyzer</li>
</ul>

</body>
</html>
